#!/usr/bin/env python3
################################################################################
# motherboard:
# 	used to return information about the motherboard in a .json
#   format. This is a helper sctipt for use with the
#   cockpit-hardware package (https://github.com/45Drives/cockpit-hardware)
#
# Copyright (C) 2020, Mark Hooper   <mhooper@45drives.com>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#   
################################################################################

import re
import subprocess
import os
import sys
import json
from pprint import pprint


# supported motherboard manufacturers and models can be adjusted here
g_dmi_mobo_fields = {
	"Manufacturer":  ["Supermicro"],
	"Product Name":  ["X11DPL-i"],
	"Serial Number": None
}

#supported CPU types
g_dmi_cpu_fields = {
	"Socket Designation":  ["CPU1","CPU2"],
	"Version":  ["Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz"],
	"Current Speed": None,
	"Max Speed": None,
}

g_ipmitool_sensor_fields = {
	"CPU1 Temp": "(C)",
	"CPU2 Temp": "(C)",
	"PW Consumption": "(W)",
	"FAN1": "(RPM)",
	"FAN2": "(RPM)",
	"FAN3": "(RPM)",
	"FAN4": "(RPM)",
	"FAN5": "(RPM)",
	"FAN6": "(RPM)",
	"FANA": "(RPM)",
	"FANB": "(RPM)"
}

g_ipmitool_fru_fields = {
	"Product Manufacturer": ["45Drives"],
	"Product Name": ["Storinator","Destroyinator"],
	"Product Part Number":["AV15","Q30","q30","av15","s45","S45","XL60","xl60"],
	"Product Serial":None
}

g_storcli64_fields = {
	"SAS9305-16i":None,
	"SAS9305-24i":None
}

################################################################################
# Name: get_motherboard_model
# Args: None
# Desc: This runs "dmidecode -t 2" and parses the output for specific fields
#       corresponding to the keys in g_dmi_mobo_fields dictionary.
#       if dmidecode discovers an unsupported motherboard model, or 
#		manufacturer, it will append " (unsupported)"  to the end of the 
#       result.  
################################################################################
def get_motherboard_model():
	mobo = []
	try:
		dmi_result = subprocess.Popen(["dmidecode","-t","2"],stdout=subprocess.PIPE,universal_newlines=True).stdout
	except:
		#print("ERROR: dmidecode is not installed")
		return False
	for line in dmi_result:
		for field in g_dmi_mobo_fields.keys():
			regex = re.search("^\s({fld}):\s+(.*)".format(fld=field),line)
			if regex != None:
				if g_dmi_mobo_fields[regex.group(1)] != None:
					if regex.group(2) in g_dmi_mobo_fields[regex.group(1)]:
						mobo.append((regex.group(1),regex.group(2)))
					else:
						mobo.append((regex.group(1),regex.group(2)+" (unsupported)"))
				else:
					mobo.append((regex.group(1),regex.group(2)))
	mobo_json_str = "{\"Motherboard\":["+json.dumps(dict(mobo))+"]}"
	return mobo_json_str


def get_cpu_info():
	cpu = []
	try:
		dmi_result = subprocess.Popen(["dmidecode","-t","4"],stdout=subprocess.PIPE,universal_newlines=True).stdout
	except:
		#print("ERROR: dmidecode is not installed")
		return False
	for line in dmi_result:
		for field in g_dmi_cpu_fields.keys():
			regex = re.search("^\s({fld}):\s+(.*)".format(fld=field),line)
			if regex != None:
				if g_dmi_cpu_fields[regex.group(1)] != None:
					if regex.group(2) in g_dmi_cpu_fields[regex.group(1)]:
						cpu.append((regex.group(1),regex.group(2)))
					else:
						cpu.append((regex.group(1),regex.group(2)+" (unsupported)"))
				else:
					cpu.append((regex.group(1),regex.group(2)))

	if len(cpu) == len(g_dmi_cpu_fields):
		#there is only 1 cpu listed
		cpu_json_str = "{\"CPU\":["+json.dumps(dict(cpu))+"]}"
	else:
		#system has 2 CPUs, but duplicate keys if used as dict
		cpu_json_str = (
			"{\"CPU\":[" +
			json.dumps(dict(cpu[0:(len(g_dmi_cpu_fields)-1)])) + 
			"," +
			json.dumps(dict(cpu[len(g_dmi_cpu_fields):-1])) +
			"]}"
		)
	return cpu_json_str



def get_sensor_readings():
	try:
		ipmitool_sensor_result = subprocess.Popen(
			["ipmitool","sensor"],stdout=subprocess.PIPE,universal_newlines=True).stdout
	except:
		#print("ERROR: ipmitool is not installed")
		return False

	sensor_readings = []
	for line in ipmitool_sensor_result:
		for field in g_ipmitool_sensor_fields.keys():
			regex = re.search("^({fld})\s+\|\s+(\S+).*".format(fld=field),line)
			if regex != None:
				if regex.group(2) != "na":
					sensor_readings.append(
						(regex.group(1),regex.group(2)+g_ipmitool_sensor_fields[regex.group(1)])
					)
	sensor_readings_json_str = "{\"Sensor Readings\":["+json.dumps(dict(sensor_readings))+"]}"
	return sensor_readings_json_str

def get_system_info():
	try:
		ipmitool_fru_result = subprocess.Popen(
			["ipmitool","fru"],stdout=subprocess.PIPE,universal_newlines=True).stdout
	except:
		#print("ERROR: ipmitool is not installed")
		return False
	system = []
	for line in ipmitool_fru_result:
		for field in g_ipmitool_fru_fields.keys():
			regex = re.search("^\s({fld})\s+:\s+(.*)".format(fld=field),line)
			if regex != None:
				if g_ipmitool_fru_fields[regex.group(1)] != None:
					if regex.group(2) in g_ipmitool_fru_fields[regex.group(1)]:
						system.append((regex.group(1),regex.group(2)))
					else:
						system.append((regex.group(1),regex.group(2)+" (unknown)"))
				else:
					system.append((regex.group(1),regex.group(2)))
	system_json_str = "{\"System Information\":["+json.dumps(dict(system))+"]}"
	return system_json_str

def get_hba_info():
	try:
		storcli64_result = subprocess.Popen(
			["/opt/tools/storcli64","show","all"],stdout=subprocess.PIPE,universal_newlines=True)
	except:
		return False
	hba_json_str = "{\"HBA Cards\":["
	card_count = 0
	for line in storcli64_result.stdout:
		for field in g_storcli64_fields.keys():
			# Model AdapterType VendId DevId SubVendId SubDevId PCIAddress 	
			regex = re.search("({fld}).*(00:\w\w:\w\w:\w\w)\s+$".format(fld=field),line)
			if regex != None:
				hba_json_str += (
					"{\"Model\":\"" + 
					regex.group(1) + 
					"\",\"PCI Address\":\"" + 
					regex.group(2) +
					"\"},"
				)
	hba_json_str = hba_json_str[:-1]
	hba_json_str += "]}"
	return hba_json_str
				
def get_lan_info():
	try:
		ipaddr_result = subprocess.Popen(
			["ip","-j","addr"],stdout=subprocess.PIPE, universal_newlines=True).stdout
	except:
		return False
	lan_json_dict_lst = json.loads(ipaddr_result.read())
	lan_json_str = "{\"Lan Information\":["
	for entry in lan_json_dict_lst:
		lan_json_str += (
			"{" + 
			"\"ifname\":" + "\"" + entry["ifname"] + "\"," +
			"\"operstate\":" + "\"" + entry["operstate"] + "\"," +
			"\"link_type\":" + "\"" + entry["link_type"] + "\"," +
			"\"mac_address\":" + "\"" + entry["address"] + "\"," +
			"\"addr_info\": ["
			)
		if len(entry["addr_info"]) > 0:  
			for i in entry["addr_info"]:
				lan_json_str += (
					"{"
					"\"family\":" + "\"" + i["family"] + "\","
					"\"local\":" + "\"" + i["local"] + "\"" +
					"},"
				)
			lan_json_str = lan_json_str[:-1]
		lan_json_str += "]},"
	lan_json_str = lan_json_str[:-1]
	lan_json_str += "]}"
	return lan_json_str

def main():
	model = get_motherboard_model()
	cpu = get_cpu_info()
	sensor_readings = get_sensor_readings()
	system = get_system_info()
	hba = get_hba_info()
	lan = get_lan_info()

	
	if model:
		print("<p>"+model)
	if cpu:
		print("<p>"+cpu+" <p> ")
	if sensor_readings:
		print("<p>"+sensor_readings+" <p> ")
	if system:
		print("<p>"+system+" <p> ")
	if hba:
		print("<p>"+hba+" <p> ")
	if lan:
		print("<p>"+lan+" <p> ")

if __name__ == "__main__":
    main()